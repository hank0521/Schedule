# 郵件排程系統核心機制說明

本文件旨在深入說明自動化排程系統中，關於郵件發送的背景服務運作邏輯，特別是它如何在高併發環境下，確保任務能夠準確、高效且不重複地被執行。

## 1. 背景排程服務 (Scheduler Service)

系統的核心是一個獨立的背景服務（Worker），它會以固定的時間間隔（例如每分鐘）被喚醒。喚醒後，它的唯一任務就是去資料庫中找出所有「已到期且待處理」的郵件任務，並將它們派發出去。

## 2. 如何篩選待寄郵件

為了找出需要處理的任務，排程服務會執行一個 SQL 查詢，該查詢基於以下三個關鍵欄位來篩選 `tblschedulemail` 資料表：

1. **`isenabled = TRUE`**: 確保只抓取處於「啟用」狀態的排程。

2. **`nextexecutetime <= CURRENT_TIMESTAMP`**: 找出執行時間已經到期（或已過期）的任務。

3. **`executionstatus = 'Pending'`**: 確保只抓取處於「待處理」狀態的任務，避免重複處理正在或已經處理過的任務。

## 3. 高併發處理機制

在一個可以水平擴展的系統中，可能會同時運行多個排程服務實體。如果採用傳統的「先查詢、後更新」方法，極有可能發生多個服務在微秒級的時間差內，讀取到同一個待處理任務，從而導致同一封郵件被重複發送。

為了解決這個嚴峻的**競爭條件 (Race Condition)** 問題，我們採用了 PostgreSQL 的原子性操作來設計查詢。

### 解決方案：單一化查詢

我們將「查詢任務」、「鎖定任務」、「更新任務狀態」這三個步驟，合併成一個單一的、不可分割的 SQL 指令：

```sql
-- 先找出最多 10 筆到期的任務，
-- 將它們的狀態更新為 'Processing'，
-- 然後將這些被成功更新的任務資料回傳。
UPDATE public.tblschedulemail
SET
    executionstatus = 'Processing'
WHERE
    id IN (
        SELECT id
        FROM public.tblschedulemail
        WHERE
            isenabled = TRUE
            AND nextexecutetime <= CURRENT_TIMESTAMP
            AND executionstatus = 'Pending'
        ORDER BY nextexecutetime
        -- 關鍵 #1: 鎖定選中的行，並跳過已被其他事務鎖定的行
        FOR UPDATE SKIP LOCKED
        -- 關鍵 #2: 批次處理，避免單一服務負載過高
        LIMIT 10
    )
-- 關鍵 #3: 將被更新的任務資料直接回傳給應用程式
RETURNING *;
```

這個查詢的精妙之處在於：

* **`FOR UPDATE SKIP LOCKED`**: 這是實現高併發的**核心**。當第一個服務實體執行此查詢並鎖定它選中的 10 筆任務時，其他同時執行查詢的服務實體會因為 `SKIP LOCKED` 而**自動跳過**這些已被鎖定的任務，轉而去尋找並鎖定下一批可用的任務。這使得多個服務可以真正地並行處理工作，而不是互相等待。

* **`LIMIT 10`**: 這是一種**批次處理**與**負載平衡**的策略。它限制了單一服務一次最多能拿取的任務數量，避免單一節點負載過重，並確保任務能夠被公平地分配給所有可用的服務實體。

* **`RETURNING *`**: 這個語句讓 `UPDATE` 指令不僅執行更新，還能像 `SELECT` 一樣回傳被更新的資料列。這使得整個操作成為一個**細分步驟**：一旦服務取得了任務資料，該任務的狀態在資料庫中**必然**已經是 `Processing`，從而徹底杜絕了重複發送的可能。
